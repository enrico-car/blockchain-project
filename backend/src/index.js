require("dotenv").config();
const express = require("express");
const cors = require('cors');
const middlewares = require("./middlewares");
const mongoose = require('mongoose');
const http = require("http");
const fs = require("fs");
const getApisRouter = require("./api/router");
const bodyParser = require("body-parser");
const path = require("path");

// Blockchain Dependences
const { Web3 } = require("web3");
const CashbackToken = require("./utils/abis/CashbackToken.json");
const TransactionManager = require("./utils/abis/TransactionManager.json");

const app = express();
middlewares(app);

app.use(cors());

app.use(bodyParser.json());
app.use("/api", getApisRouter());

const port = process.env.PORT || 3000;

// Test for connection to the Hardhat network
// implemented as an endpoint
app.get("/", async (req, res) => {
  const web3 = new Web3(process.env.CHAIN_URL);
  const account = web3.eth.accounts.privateKeyToAccount(
    process.env.PRIVATE_KEY
  );

  const contract = new web3.eth.Contract(
    CashbackToken,
    process.env.CASHBACK_TOKEN_ADDRESS
  );

  try {
    // Will call a “constant” method and execute its smart contract method in the EVM
    const owner_token = await contract.methods
      .owner(process.env.CASHBACK_TOKEN_ADDRESS)
      .call();
    console.log(owner_token);

    const owner_handler = await contract.methods
      .owner(process.env.CASHBACK_HANDLER_ADDRESS)
      .call();
    console.log(owner_handler);

    const balance = await contract.methods.balanceOf(account.address).call();
    console.log(balance);
  } catch (error) {
    console.log(error);
  }

  res.send("Hello World!");
});

// https connection options, not used at the moment

// const httpsOptions = {
//   key: fs.readFileSync("./certificate/private.key"),
//   cert: fs.readFileSync("./certificate/server.crt"),
// };

// https.createServer(httpsOptions, app).listen(port, async () => {
//   await db.connect();
//   console.log(`Server HTTPS avviato su https://localhost:${port}`);
// });

http.createServer(app).listen(port, async () => {
  //connection string for remote db
  // await mongoose.connect(`mongodb+srv://${process.env.DB_USERNAME}:${process.env.DB_PASSWORD}@blockchain.vjumxip.mongodb.net/?retryWrites=true&w=majority&appName=Blockchain`);
  //connection string for local db
  await mongoose.connect(`mongodb://mongodb:27017/blockchain`);

  //store in db all the wallets generated by hardhat
  addWalletsToDB();

  //automatically call a smart contract function to remove
  //expired transactions
  callEveryXSeconds(removeExpiredTransactions, 5 * 60 * 1000);

  console.log(`Server HTTP avviato su http://localhost:${port}`);
});

process.on("SIGINT", () => {
  console.log("Shutting down the server");
  process.exit();
});


/**
 * the function simply takes the list of the wallets generated by hardhat
 * and stores them into the db by giving automatically other metadata as
 * the role it has in the blockchain (retailer, manufacturer, pharmacy), the name, etc.
 */
function addWalletsToDB() {
  
  const walletsFile = "wallets";
  const walletPath = path.resolve(
    __dirname,
    "utils",
    `${walletsFile}.json`
  );
  console.log("Wallets file path:", walletPath);

  if (fs.existsSync(walletPath)) {
    const walletsData = fs.readFileSync(walletPath, "utf8");
    const wallets = JSON.parse(walletsData);

    const userModelFile = "User";
    const userModelPath = path.resolve(
      __dirname,
      "models",
      `${userModelFile}.js`
    );
    const User = require(userModelPath);

    wallets.forEach(async (userWallet, index) => {
      let role = "";
      try {
        console.log(index, userWallet.address);
        const existingUser = await User.findOne({ wallet: userWallet.address });
        if (!existingUser) {
          if(index == 0) {
            role = "deployer";
          }
          else if(index == 1) {
            role = "manufacturer";
          }
          else if(index >= 2 && index < 15) {
            role = "retailer";
          }
          else if(index >= 15) {
            role = "pharmacy";
          }
          const newWallet = new User({wallet: userWallet.address, realName: `Name ${index}`, location: `Location ${index}`, type: role});
          await newWallet.save();
          console.log(`Added wallet: ${userWallet.address}`);
        }
      } catch (error) {
        console.error(`Error adding wallet ${userWallet.address}:`, error);
      }
    });
  } else {
    console.log("No wallets file found to add to the database.");
  }
}

/**
 * function that calls the smart contract function to remove all the expired transactions
 * that have an age larger than the one passed as a parameter.
 */
async function removeExpiredTransactions(){
  const maxAge = 5 * 60; //in seconds
  console.log("Calling remove expired transactions");
  try{
    const web3 = new Web3(process.env.CHAIN_URL);
    const contractExpiredTransactions = new web3.eth.Contract(
      TransactionManager,
      process.env.TRANSACTION_MANAGER_ADDRESS
    );

    const result = await contractExpiredTransactions.methods
      .removeExpiredTransactions(maxAge)
      .send({ from: process.env.PUBLIC_KEY });
    //console.log(result);
  } catch(error){
    console.log(error);
  }
}

/**
 * wrapper function that allows to call automatically a callback function every 
 * x milliseconds
 * @param {*} callback the function to be called automatically
 * @param {*} millis time passed before the next call
 */
function callEveryXSeconds(callback, millis) {
  if (typeof callback !== "function") {
    throw new Error("callback must be a function");
  }
  if (typeof millis !== "number" || millis <= 0) {
    throw new Error("millis must be a positive number");
  }

  setInterval(callback, millis);
}
